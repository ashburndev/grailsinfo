Elastic

APACHE SOLR: Apache Solr is an open source search engine built on Apache Lucene in 2004. As a strong competitor to Elasticsearch, Solr has a thriving user community and I must say closer to opensource than Elasticsearch (Elastic moved from Apache to Elastic Licence and Server Side Public Licence (SSPL) in early 2021). Both Solr and Elasticsearch excel in full-text searching, however Elasticsearch may have an edge when it comes to analytics. While both these products compete in almost all functionality from head to toe, Solr has been a favourite for large static datasets working in a big data ecosystem. Obviously one has to run through prototypes and analysis to pick a product, the general trend is that most projects looking up for integrating with a search engine for the first time may look towards Elaticsearch due to its relatively no-hurdle startup time. One must carry a detailed comparison for the use cases they intend to use the search engine before adopting and embracing them.
The burst of big data coupled with technological innovations paved the way to modern search engines. Modern search engines are highly effective and better suited to searching and providing relevance Regardless of whether the data is structured, semi-structured, or unstructured (more than three quarters of the data is assumed to be unstructured data), modern search engines can easily query it and return the results with relevance.
As search becomes the new normal, modern search engines are trying hard to entertain the ever-growing requirements by donning new hats each day. Cheap hardware combined with the explosion of data is leading to the emergence of these modern search beasts. Let’s consider these present-day search engines in further detail in the next section.
OPENSEARCH: Elastic changed their licencing policy in 2021, which applies to Elasticsearch release versions 7.11 and above. The licencing has been moved from open source to a dual licence under an Elastic Licence and a Server Side Public Licence (SSPL). This licence allows the community to use the product for free as expected. Managed service providers, however, cannot provide the products as services anymore. (There is a spat between Elastic and AWS on this move with AWS creating a forked version of Elasticsearch - called Open Distro for Elasticsearch - offering it as a managed service.)
As Elastic moved from the open source licensing model to the SSPL model, a new product called OpenSearch (https://opensearch.org) was born in order to fill the gaping hole left by the new licensing agreement. The base code for OpenSearch was created from the open source Elasticsearch and Kibana version 7.10.2. The product’s first GA version 1.0 was released in July 2021. Watch out for OpenSearch becoming a competitor to Elasticsearch in the search engine space.


2.1.6 Constituents of the request
The request we sent (PUT books/_doc/1) needs a bit of distilling. There are five parts to this request, and I’ll quickly go over each of these here:
• PUT method—PUT is a HTTP verb (also known as a method) that indicates we are sending a request to the server to create a resource (a book document in this case). Elasticsearch uses the HTTP protocol for its RESTful API invocations, so we expect PUT, POST, GET, DELETE, and other standard HTTP methods in the request URL syntax.
• The books index—The books in our URL is called an index, which is a bucket for collecting all book documents. It is similar to a table in a relational database. Only book documents are stored in this books index.
• The _doc endpoint—The _doc in our URL is the endpoint. This is a constant part of the path that’s associated with the operation being performed. In earlier versions of Elasticsearch (version < 7.0), the _doc’s place used to be filled up by a document’s mapping type. The mapping types were deprecated and _doc came to replace the document’s mapping types as a generic constant endpoint path in the URL.
• Document ID—The number 1 in our URL represents the document’s ID. It is like a primary key for a record in a database. We use this identifier to retrieve the document.
• Request body—The body of the request is the JSON representation of the book data. Elasticsearch supports nested objects sent over in JSON’s nested objects format.
NOTE DOCUMENT TYPES AND THE _DOC ENDPOINT Prior to the 7.x version for Elasticsearch, an index could hold multiple types of entities (for example, a books index could hold not just books but also book_reviews, book_sales, bookshops, and so on). Having all types of documents in a single index led to complications. Field mappings were shared across multiple types, thus leading to errors as well as data sparsity. To avoid issues with types and their management, Elastic decided to remove the types altogether. In earlier versions, the invocation URL with a type would look something like this: <index_name>/<type>/<id> (or, for example, books/book/1). The types were deprecated in version 7.x. Now we are expected to have an index dedicated to one and only one type: _doc is an endpoint etched into the URL. We will learn about removal of types in chapter 5 on document operations.
The gist is that we used a HTTP PUT method to index a document with an ID of 1 into the books index for Elasticsearch. When indexing our first document, did you notice we didn’t create a schema at all? Instead, we indexed the document by invoking the API, right?
Unlike in a relational database, Elasticsearch doesn’t ask us to create the schema beforehand (its schema-less feature) and is happy to derive the schema from the first document that it indexes. It also creates the index (the books index to be precise). The bottom line is that Elasticsearch doesn’t like to get in our way during development. That said, we must follow the best practice of creating our own schemas beforehand in production environments.
In this section, we successfully indexed a document. Let’s follow the same process and index a couple of documents.
